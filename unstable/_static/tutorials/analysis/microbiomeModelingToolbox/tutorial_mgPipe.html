<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="generator" content="MATLAB R2016a"><meta http-equiv="X-UA-Compatible" content="IE=edge,IE=9,chrome=1"><title>Creation and simulation of personalized microbiota models through metagenomic data integration</title><style type="text/css">
* {margin: 0; padding: 0;}
body {text-align: start; line-height: 17.234px; min-height: 0px; white-space: normal; color: rgb(0, 0, 0); font-family: Consolas, Inconsolata, Menlo, monospace; font-style: normal; font-size: 14px; font-weight: normal; text-decoration: none; white-space: normal; }
h1, h2 {font-weight: normal;}
.content { padding: 30px; }

.S0 { margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S1 { line-height: 26.4px; min-height: 24px; white-space: pre-wrap; color: rgb(213, 80, 0); font-family: Helvetica, Arial, sans-serif; font-size: 22px; white-space: pre-wrap; margin-left: 4px; margin-top: 3px; margin-bottom: 15px; margin-right: 10px;  }
.S2 { min-height: 0px; margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S3 { line-height: 20.576px; min-height: 20px; white-space: pre-wrap; color: rgb(60, 60, 60); font-family: Helvetica, Arial, sans-serif; font-size: 16px; font-weight: bold; white-space: pre-wrap; margin-left: 4px; margin-top: 3px; margin-bottom: 9px; margin-right: 10px;  }
.S4 { line-height: 21px; min-height: 17px; white-space: pre-wrap; font-family: Helvetica, Arial, sans-serif; white-space: pre-wrap; margin-left: 4px; margin-top: 2px; margin-bottom: 9px; margin-right: 10px;  }
.S5 { font-family: Helvetica, Arial, sans-serif; margin-left: 0px; margin-top: 10px; margin-bottom: 20px; margin-right: 0px;  }
.S6 { text-align: left; line-height: 21px; white-space: pre-wrap; white-space: pre-wrap; margin-left: 56px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S7 { font-weight: bold; margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S8 { margin-left: 3px; margin-top: 4px; margin-bottom: 4px; margin-right: 3px;  }
.S9 { line-height: 15.5927px; min-height: 18px; white-space: nowrap; font-size: 12.6667px; white-space: nowrap; margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S10 { min-height: 0px; white-space: pre; color: rgb(34, 139, 34); white-space: pre; margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 45px;  }
.S11 { min-height: 0px; white-space: pre; white-space: pre; margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 45px;  }
.S12 { min-height: 0px; white-space: pre; color: rgb(0, 0, 255); white-space: pre; margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S13 { min-height: 0px; white-space: pre; white-space: pre; margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S14 { min-height: 0px; white-space: pre; color: rgb(160, 32, 240); white-space: pre; margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S15 { margin-left: 3px; margin-top: 10px; margin-bottom: 4px; margin-right: 3px;  }
.S16 { min-height: 0px; white-space: pre; color: rgb(0, 0, 255); white-space: pre; margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 45px;  }
.S17 { min-height: 0px; font-weight: bold; margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }

.LineNodeBlock {margin: 10px 0 10px 0;}
.LineNodeBlock+.paragraphNode {margin-top: 10px;}
.lineNode {padding-left: 10px; background-color: #F7F7F7; border-left: 1px solid #E9E9E9; border-right: 1px solid #E9E9E9;}
.inlineWrapper:first-child .lineNode,.inlineWrapper.outputs+.inlineWrapper .lineNode {padding-top: 5px; border-top: 1px solid #E9E9E9;}
.inlineWrapper:last-child .lineNode,.inlineWrapper.outputs .lineNode {padding-bottom: 5px; border-bottom: 1px solid #E9E9E9;}
.lineNode .textBox {white-space: pre;}
</style></head><body><div class = "content"><div class = 'SectionBlock containment active'><h1 class = "S1"><span class = "S2">Creation and simulation of personalized microbiota models through metagenomic data integration</span></h1></div><p class = "S0"></p><div class = 'SectionBlock containment'><h2 class = "S3"><span class = "S2">Author: Federico Baldini, Molecular Systems Physiology Group, University of Luxembourg.</span></h2></div><p class = "S0"></p><div class = 'SectionBlock containment'><h2 class = "S3"><span class = "S2">INTRODUCTION</span></h2><p class = "S4"><span class = "S2">This tutorial shows the steps that MgPipe automatically performs to create and simulate personalized microbiota models trough metagenomic data integration. Please note that this tutorial uses as an example a small dataset (4 columns and 30 rows) with the purpose of demonstrating the functionalities of the pipeline. We recommend using high-performance computing clusters when assembling and simulating from bigger datasets. </span></p><p class = "S4"><span class = "S2">The pipeline is divided into 3 parts:</span></p><ol class = "S5"><li class = "S6"><span class = "S7">[PART 1]</span><span class = "S0"> Analysis of individuals' specific microbes abundances is computed. Individuals' metabolic diversity in relation to microbiota size and disease presence, as well as, classical multidimensional scaling (PCoA) on individuals' reaction repertoire are examples.</span></li><li class = "S6"><span class = "S7">[PART 2]</span><span class = "S0">: 1 Constructing a global metabolic model (setup) containing all the microbes listed in the study. 2 Building individuals' specific models integrating abundance data retrieved from metagenomics. For each organism, reactions are coupled to their objective function. </span></li><li class = "S6"><span class = "S7">[PART 3]</span><span class = "S0"> A specific range of growth is imposed for each microbiota model and Simulations under specific diet regimes are carried. Set of standard analysis to apply to the personalized models. PCA of computed MNPCs of individuals as for example.</span></li></ol></div><p class = "S0"></p><div class = 'SectionBlock containment'><h2 class = "S3"><span class = "S2">USAGE</span></h2><p class = "S4"><span class = "S2">Normally, once provided all the input variables in the driver (StartMgPipe), the only action required is to run the driver itself. However, for this tutorial, we will disable the autorun functionality and compute each section manually. </span></p></div><p class = "S0"></p><div class = 'SectionBlock containment'><h2 class = "S3"><span class = "S2">DRIVER</span></h2><p class = "S4"><span class = "S2">This file has to be modified by the user to launch the pipeline and to define inputs and outputs files and locations. </span></p></div><p class = "S0"></p><div class = 'SectionBlock containment'><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10">% We first set the paths to input and output files</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">initCobraToolbox(0);</span></p></div></div></div><p class = "S0"></p><div class = 'SectionBlock containment'><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10">% path to where the COBRA Toolbox is located</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S12">global </span><span class = "S11">CBTDIR</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11"></span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10">% path to microbe models (download AGORA models from https://www.vmh.life/#downloadview)</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S13">modPath = [getenv(</span><span class = "S14">'HOME'</span><span class = "S13">) filesep </span><span class = "S14">'AGORA' </span><span class = "S13">filesep </span><span class = "S14">'mat'</span><span class = "S11">];</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11"></span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10">% path where to save results</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S13">resPath = [CBTDIR filesep </span><span class = "S14">'.tmp'</span><span class = "S11">]</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11"></span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10">% path to and name of the file with dietary information. Here, </span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10">% we will use an "Average European" diet that is located in the </span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10">% DietImplementation folder.</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S13">dietFilePath=[CBTDIR filesep </span><span class = "S14">'papers' </span><span class = "S13">filesep </span><span class = "S14">'2018_microbiomeModelingToolbox' </span><span class = "S13">filesep </span><span class = "S14">'resources' </span><span class = "S13">filesep </span><span class = "S14">'AverageEuropeanDiet'</span><span class = "S11">];</span></p></div></div></div><p class = "S0"></p><div class = 'SectionBlock containment'><p class = "S4"><span class = "S2">Then we set the path and the name of the file from which to load the abundances. For this tutorial, to reduce the time of computations, we will use a reduced version of the example file (normCoverageReduced.csv) provided in the folder Resources: only 4 individuals and 30 strains will be considered. Plese, note that abundances are normalized to a total sum of one. </span></p><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S13">abunFilePath=[CBTDIR filesep </span><span class = "S14">'tutorials' </span><span class = "S13">filesep </span><span class = "S14">'analysis' </span><span class = "S13">filesep </span><span class = "S14">'microbiomeModelingToolbox' </span><span class = "S13">filesep </span><span class = "S14">'normCoverageReduced.csv'</span><span class = "S11">];</span></p></div></div></div><p class = "S0"></p><div class = 'SectionBlock containment'><p class = "S4"><span class = "S2">Next inputs will define:</span></p><ol class = "S5"><li class = "S6"><span class = "S0">name of the objective function of organisms</span></li><li class = "S6"><span class = "S0">format to use to save images</span></li><li class = "S6"><span class = "S0">number of cores to use for the pipeline execution </span></li><li class = "S6"><span class = "S0">if to enable automatic detection and correction of possible bugs</span></li><li class = "S6"><span class = "S0">if to enable compatibility mode </span></li><li class = "S6"><span class = "S0">if stratification criteria are available</span></li><li class = "S6"><span class = "S0">if to simulate also a rich diet</span></li><li class = "S6"><span class = "S0">if to use an external solver and save models with diet</span></li><li class = "S6"><span class = "S0">the type of FVA function to use to solve </span></li></ol><p class = "S4"><span class = "S2">The following setting should work for almost any system, but please check carefully to be sure these options are valid for you. A more detailed description of these variables is available in the documentation. </span></p><p class = "S4"><span class = "S2">The same inputs need to be set in the driver file StartMgPipe when running mgPipe outside of this tutorial or directly in the "initMgPipe" function.</span></p><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10">% name of the objective function of organisms</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S13">objre={</span><span class = "S14">'EX_biomass(e)'</span><span class = "S11">};</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11"></span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10">% the output is a vectorized picture, change to '-dpng' for .png</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S13">figForm = </span><span class = "S14">'-depsc'</span><span class = "S11">;</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11"></span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10">% number of cores dedicated for parallelization</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">numWorkers = 2;</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11"></span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10">% autofix for names mismatch</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">autoFix = true; </span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11"></span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10">% if outputs in open formats should be produced for each section </span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">compMod = false;</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11"></span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10">% if documentation (.csv) on stratification criteria is available</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S13">indInfoFilePath=</span><span class = "S14">'none'</span><span class = "S11">; </span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11"></span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10">% to enable also rich diet simulations </span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">rDiet = false; </span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11"></span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10">% if to use an external solver and save models with diet</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">extSolve = false; </span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11"></span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10">% the type of FVA function to use to solve</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">fvaType = true;</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11"></span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10">% to turn off the autorun to be able to manually execute each part of the pipeline</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">autorun = false; </span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11"></span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">[init,modPath,~,resPath,dietFilePath,abunFilePath,indInfoFilePath,objre,figForm,numWorkers,autoFix,compMod,rDiet,extSolve,fvaType,autorun]= initMgPipe(modPath, CBTDIR, resPath, dietFilePath, abunFilePath, indInfoFilePath, objre, figForm, numWorkers, autoFix, compMod, rDiet,extSolve,fvaType,autorun);</span></p></div></div></div><p class = "S0"></p><div class = 'SectionBlock containment'><h2 class = "S3"><span class = "S2">PIPELINE: [PART 1]</span></h2><p class = "S4"><span class = "S2">The number of organisms, their names, the number of samples and their identifiers are automatically detected from the input file. </span></p><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">[patNumb, sampName, strains] = getIndividualSizeName(abunFilePath)</span></p></div></div></div><p class = "S0"></p><div class = 'SectionBlock containment'><p class = "S4"><span class = "S2">Now we detect from the content of the results folder if PART1 was already computed: if the associated file is already present in the results folder its execution is skipped else its execution starts</span></p><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S13">[mapP] = detectOutput(resPath, </span><span class = "S14">'mapInfo.mat'</span><span class = "S11">);</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11"></span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S12">if </span><span class = "S11">~isempty(mapP)</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S13">    s= </span><span class = "S14">'mapping file found: loading from resPath and skipping [PART1] analysis'</span><span class = "S11">;</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">    disp(s)</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S13">    load(strcat(resPath,</span><span class = "S14">'mapInfo.mat'</span><span class = "S11">))</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S16">end</span></p></div></div></div><p class = "S0"></p><div class = 'SectionBlock containment'><p class = "S4"><span class = "S2">In case PART 1 was not computed we will compute it now. We will first load the models and create a cell array containing them. This cell array will be used as input by many functions in the pipeline. Any possible constraint from each model reactions will be removed. Moreover we will run and subsequentially plot the results of some analysis that are computed. The main outputs are:</span></p><ol class = "S5"><li class = "S6"><span class = "S7">Metabolic diversity</span><span class = "S0"> The number of mapped organisms for each individual compared to the total number of unique reactions (extrapolated by the number of reactions of each organism).Please, note that bigger circles with a number inside represent overlapping individuals for metabolic diversity. </span></li><li class = "S6"><span class = "S7">Classical multidimensional scaling of each individual reactions repertoire</span></li></ol><p class = "S4"><span class = "S2">Other outputs computed during this phase are saved together with the previous ones into the</span><span class = "S2"> </span><span class = "S17">.mat</span><span class = "S2"> file called</span><span class = "S2"> </span><span class = "S17">mapInfo.mat</span><span class = "S2">. If the</span><span class = "S2"> </span><span class = "S17">compMod</span><span class = "S2"> option is enabled (disabled here and by default in the</span><span class = "S2"> </span><span class = "S17">mgPipe</span><span class = "S2"> pipeline) these results are outputted as different</span><span class = "S2"> </span><span class = "S17">.csv</span><span class = "S2"> files. For simplicity reasons we will not discuss these additional outputs in this tutorial: for a description of them, please refer to the documentation. </span></p><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S13">[mapP] = detectOutput(resPath,</span><span class = "S14">'mapInfo.mat'</span><span class = "S11">)</span></p></div></div></div><p class = "S0"></p><div class = 'SectionBlock containment'><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S12">if </span><span class = "S11">isempty(mapP)</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S13">    </span><span class = "S10">% Loading models </span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">    models = loadUncModels(modPath,strains,objre);</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">    </span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S13">    </span><span class = "S10">% Computing genetic information</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">    [reac,micRea,binOrg,patOrg,reacPat,reacNumb,reacSet,reacTab,reacAbun,reacNumber] = getMappingInfo(models,abunFilePath,patNumb);</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S13">    writetable(cell2table(reacAbun,</span><span class = "S14">'VariableNames'</span><span class = "S13">,[</span><span class = "S14">'Reactions'</span><span class = "S13">;sampName]'),strcat(resPath,</span><span class = "S14">'reactions.csv'</span><span class = "S11">));</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">    </span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S13">    </span><span class = "S10">% Plotting genetic information</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">    [PCoA] = plotMappingInfo(resPath,patOrg,reacPat,reacTab,reacNumber,indInfoFilePath,figForm,sampName,strains); </span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">    </span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S13">    </span><span class = "S12">if </span><span class = "S11">compMod == 1</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S13">       mkdir(strcat(resPath,</span><span class = "S14">'compfile'</span><span class = "S11">))</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S13">       writetable([array2table(reac),array2table(reacTab,</span><span class = "S14">'VariableNames'</span><span class = "S13">,sampName')],[resPath </span><span class = "S14">'compfile' </span><span class = "S13">filesep </span><span class = "S14">'ReacTab.csv'</span><span class = "S11">])</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S13">       writetable(cell2table(reacSet,</span><span class = "S14">'VariableNames'</span><span class = "S13">,sampName'),[resPath </span><span class = "S14">'compfile' </span><span class = "S13">filesep </span><span class = "S14">'reacSet.csv'</span><span class = "S11">])</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S13">       writetable([array2table(strains),array2table(reacPat,</span><span class = "S14">'VariableNames'</span><span class = "S13">,sampName')],[resPath </span><span class = "S14">'compfile' </span><span class = "S13">filesep </span><span class = "S14">'ReacPat.csv'</span><span class = "S11">])</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S13">       csvwrite(strcat(resPath,</span><span class = "S14">'compfile/PCoA_tab.csv'</span><span class = "S11">),PCoA)</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S13">    </span><span class = "S16">end</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">    </span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S13">    </span><span class = "S10">%Save all the created variables</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">    </span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S13">    </span><span class = "S10">%Create tables and save all the created variables</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S13">    reacTab=[array2table(reac),array2table(reacTab,</span><span class = "S14">'VariableNames'</span><span class = "S13">,sampName')],[resPath </span><span class = "S14">'compfile' </span><span class = "S13">filesep </span><span class = "S14">'ReacTab.csv'</span><span class = "S11">];</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S13">    reacSet=cell2table(reacSet,</span><span class = "S14">'VariableNames'</span><span class = "S11">,sampName');</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S13">    reacPat=[array2table(strains),array2table(reacPat,</span><span class = "S14">'VariableNames'</span><span class = "S11">,sampName')];</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">    </span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S13">    save(strcat(resPath,</span><span class = "S14">'mapInfo.mat'</span><span class = "S11">))</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S16">end</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10">%end of trigger for Autoload</span></p></div></div></div><p class = "S0"></p><div class = 'SectionBlock containment'><h2 class = "S3"><span class = "S2">PIPELINE: [PART 2.1]</span></h2><p class = "S4"><span class = "S2">Checking consistency of inputs: if autofix == 0 halts execution with error msg if inconsistencies are detected, otherwise it really tries hard to fix the problem and continues execution when possible. </span></p><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">[autoStat,fixVec,strains]=checkNomenConsist(strains,autoFix);</span></p></div></div></div><p class = "S0"></p><div class = 'SectionBlock containment'><p class = "S4"><span class = "S2">Now we detect from the content of the results folder If PART2 was already computed: if the associated file is already present in the results folder its execution is skipped else its execution starts</span></p><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S13">[mapP]=detectOutput(resPath,</span><span class = "S14">'Setup_allbacs.mat'</span><span class = "S11">);</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11"></span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S12">if </span><span class = "S11">isempty(mapP)</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">    modbuild = 1;</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S16">else</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">    modbuild = 0;</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S13">    s= </span><span class = "S14">'global setup file found: loading from resPath and skipping [PART2.1] analysis'</span><span class = "S11">;</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">    disp(s)</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S16">end</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10">%end of trigger for Autoload</span></p></div></div></div><p class = "S0"></p><div class = 'SectionBlock containment'><p class = "S4"><span class = "S2">A model joining all the reconstructions contained in the study will be created in this section. This model will be later used, integrating abundances coming from the metagenomic sequencing, to derive the different microbiota models. The result of this section will be automatically saved in the results folder. </span></p><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S12">if </span><span class = "S11">modbuild == 1</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">   setup=fastSetupCreator(models, strains, {},objre)</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S13">   setup.name=</span><span class = "S14">'Global reconstruction with lumen / fecal compartments no host'</span><span class = "S11">;</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">   setup.recon=0;</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S13">   save(strcat(resPath,</span><span class = "S14">'Setup_allbacs.mat'</span><span class = "S13">), </span><span class = "S14">'setup'</span><span class = "S11">)</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S16">end</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11"></span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S12">if </span><span class = "S11">modbuild==0</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S13">    load(strcat(resPath,</span><span class = "S14">'Setup_allbacs.mat'</span><span class = "S11">)) </span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S16">end</span></p></div></div></div><p class = "S0"></p><div class = 'SectionBlock containment'><h2 class = "S3"><span class = "S2">PIPELINE: [PART 2.2]</span></h2><p class = "S4"><span class = "S2">Now we will create the different microbiota models integrating the given abundances. Coupling constraints and personalized "cumulative biomass" objective functions are also added. Models that are already existent will not be recreated, and new microbiota models will be saved in the results folder. </span></p><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">[createdModels]=createPersonalizedModel(abunFilePath,resPath,setup,sampName,strains,patNumb)</span></p></div></div></div><p class = "S0"></p><div class = 'SectionBlock containment'><h2 class = "S3"><span class = "S2">PIPELINE: [PART 3]</span></h2><p class = "S4"><span class = "S2">In this phase, for each microbiota model, a diet, in the form of set constraints to the exchanges reactions of the diet compartment, is integrated. Flux Variability analysis for all the exchange reactions of the diet and fecal compartment is also computed and saved in a file called "simRes". Specifically what computed and saved are:</span></p><ol class = "S5"><li class = "S6"><span class = "S7">ID</span><span class = "S0"> a vector containing the names of metabolites for which FVA of exchange reactions was computed</span></li><li class = "S6"><span class = "S7">fvaCt</span><span class = "S0"> a cell array containing min flux trough uptake and max trough secretion exchanges (later used for computing NMPCs)</span></li><li class = "S6"><span class = "S7">nsCT</span><span class = "S0"> a cell array containing max flux trough uptake and min trough secretion exchanges</span></li><li class = "S6"><span class = "S7">presol</span><span class = "S0"> an array containing the value of objectives for each microbiota model with rich and selected diet</span></li><li class = "S6"><span class = "S7">inFesMat</span><span class = "S0"> cell array containing the names of the microbiota models that reported an infeasible status when solved for their objective </span></li></ol><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">[ID,fvaCt,nsCt,presol,inFesMat]=microbiotaModelSimulator(resPath,setup,sampName,dietFilePath,rDiet,0,extSolve,patNumb,fvaType)</span></p></div></div></div><p class = "S0"></p><div class = 'SectionBlock containment'><p class = "S4"><span class = "S2">Finally, NMPCs (net maximal production capability) are computed in a metabolite resolved manner and saved in a comma delimited file in the results folder. NMPCs indicate the maximal production of each metabolite and are computed as the absolute value of the sum of the maximal secretion flux with the maximal uptake flux. The similarity of metabolic profiles (using the different NMPCs as features) between individuals is also evaluated with classical multidimensional scaling. </span></p><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">[Fsp,Y]= mgSimResCollect(resPath,ID,sampName,rDiet,0,patNumb,indInfoFilePath,fvaCt,figForm);</span></p></div></div></div><p class = "S0"></p><div class = 'SectionBlock containment'><p class = "S4"><span class = "S2">Additionally, it is possible to retrieve and export, comprehensively, all the results (fluxes) computed during the simulations for a specified diet. Since FVA is computed on diet and fecal exchanges, every metabolite will have four different values for each individual, values corresponding min and max of uptake and secretion. </span></p><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">[finRes] = extractFullRes(resPath, ID, 'sDiet', sampName, fvaCt, nsCt);</span></p></div></div></div></div>
<!-- 
##### SOURCE BEGIN #####
%% Creation and simulation of personalized microbiota models through metagenomic data integration
%% Author: Federico Baldini, Molecular Systems Physiology Group, University of Luxembourg.
%% INTRODUCTION
% This tutorial shows the steps that MgPipe automatically performs to create 
% and simulate personalized microbiota models trough metagenomic data integration. 
% Please note that this tutorial uses as an example a small dataset (4 columns 
% and 30 rows) with the purpose of demonstrating the functionalities of the pipeline. 
% We recommend using high-performance computing clusters when assembling and simulating 
% from bigger datasets. 
% 
% The pipeline is divided into 3 parts:
% 
% # *[PART 1]* Analysis of individuals' specific microbes abundances is computed. 
% Individuals' metabolic diversity in relation to microbiota size and disease 
% presence, as well as, classical multidimensional scaling (PCoA) on individuals' 
% reaction repertoire are examples.
% # *[PART 2]*: 1 Constructing a global metabolic model (setup) containing all 
% the microbes listed in the study. 2 Building individuals' specific models integrating 
% abundance data retrieved from metagenomics. For each organism, reactions are 
% coupled to their objective function. 
% # *[PART 3]* A specific range of growth is imposed for each microbiota model 
% and Simulations under specific diet regimes are carried. Set of standard analysis 
% to apply to the personalized models. PCA of computed MNPCs of individuals as 
% for example.
%% USAGE
% Normally, once provided all the input variables in the driver (StartMgPipe), 
% the only action required is to run the driver itself. However, for this tutorial, 
% we will disable the autorun functionality and compute each section manually. 
%% DRIVER
% This file has to be modified by the user to launch the pipeline and to define 
% inputs and outputs files and locations. 

% We first set the paths to input and output files
initCobraToolbox(0);
% path to where the COBRA Toolbox is located
global CBTDIR

% path to microbe models (download AGORA models from https://www.vmh.life/#downloadview)
modPath = [getenv('HOME') filesep 'AGORA' filesep 'mat'];

% path where to save results
resPath = [CBTDIR filesep '.tmp']

% path to and name of the file with dietary information. Here, 
% we will use an "Average European" diet that is located in the 
% DietImplementation folder.
dietFilePath=[CBTDIR filesep 'papers' filesep '2018_microbiomeModelingToolbox' filesep 'resources' filesep 'AverageEuropeanDiet'];
%% 
% Then we set the path and the name of the file from which to load the abundances. 
% For this tutorial, to reduce the time of computations, we will use a reduced 
% version of the example file (normCoverageReduced.csv) provided in the folder 
% Resources: only 4 individuals and 30 strains will be considered. Plese, note 
% that abundances are normalized to a total sum of one. 

abunFilePath=[CBTDIR filesep 'tutorials' filesep 'analysis' filesep 'microbiomeModelingToolbox' filesep 'normCoverageReduced.csv'];
%% 
% Next inputs will define:
% 
% # name of the objective function of organisms
% # format to use to save images
% # number of cores to use for the pipeline execution 
% # if to enable automatic detection and correction of possible bugs
% # if to enable compatibility mode 
% # if stratification criteria are available
% # if to simulate also a rich diet
% # if to use an external solver and save models with diet
% # the type of FVA function to use to solve 
% 
% The following setting should work for almost any system, but please check 
% carefully to be sure these options are valid for you. A more detailed description 
% of these variables is available in the documentation. 
% 
% The same inputs need to be set in the driver file StartMgPipe when running 
% mgPipe outside of this tutorial or directly in the "initMgPipe" function.

% name of the objective function of organisms
objre={'EX_biomass(e)'};

% the output is a vectorized picture, change to '-dpng' for .png
figForm = '-depsc';

% number of cores dedicated for parallelization
numWorkers = 2;

% autofix for names mismatch
autoFix = true; 

% if outputs in open formats should be produced for each section 
compMod = false;

% if documentation (.csv) on stratification criteria is available
indInfoFilePath='none'; 

% to enable also rich diet simulations 
rDiet = false; 

% if to use an external solver and save models with diet
extSolve = false; 

% the type of FVA function to use to solve
fvaType = true;

% to turn off the autorun to be able to manually execute each part of the pipeline
autorun = false; 

[init,modPath,~,resPath,dietFilePath,abunFilePath,indInfoFilePath,objre,figForm,numWorkers,autoFix,compMod,rDiet,extSolve,fvaType,autorun]= initMgPipe(modPath, CBTDIR, resPath, dietFilePath, abunFilePath, indInfoFilePath, objre, figForm, numWorkers, autoFix, compMod, rDiet,extSolve,fvaType,autorun);
%% PIPELINE: [PART 1]
% The number of organisms, their names, the number of samples and their identifiers 
% are automatically detected from the input file. 

[patNumb, sampName, strains] = getIndividualSizeName(abunFilePath)
%% 
% Now we detect from the content of the results folder if PART1 was already 
% computed: if the associated file is already present in the results folder its 
% execution is skipped else its execution starts

[mapP] = detectOutput(resPath, 'mapInfo.mat');

if ~isempty(mapP)
    s= 'mapping file found: loading from resPath and skipping [PART1] analysis';
    disp(s)
    load(strcat(resPath,'mapInfo.mat'))
end
%% 
% In case PART 1 was not computed we will compute it now. We will first 
% load the models and create a cell array containing them. This cell array will 
% be used as input by many functions in the pipeline. Any possible constraint 
% from each model reactions will be removed. Moreover we will run and subsequentially 
% plot the results of some analysis that are computed. The main outputs are:
% 
% # *Metabolic diversity* The number of mapped organisms for each individual 
% compared to the total number of unique reactions (extrapolated by the number 
% of reactions of each organism).Please, note that bigger circles with a number 
% inside represent overlapping individuals for metabolic diversity. 
% # *Classical multidimensional scaling of each individual reactions repertoire*
% 
% Other outputs computed during this phase are saved together with the previous 
% ones into the *.mat* file called *mapInfo.mat*. If the *compMod* option is enabled 
% (disabled here and by default in the *mgPipe* pipeline) these results are outputted 
% as different *.csv* files. For simplicity reasons we will not discuss these 
% additional outputs in this tutorial: for a description of them, please refer 
% to the documentation. 

[mapP] = detectOutput(resPath,'mapInfo.mat')
if isempty(mapP)
    % Loading models 
    models = loadUncModels(modPath,strains,objre);
    
    % Computing genetic information
    [reac,micRea,binOrg,patOrg,reacPat,reacNumb,reacSet,reacTab,reacAbun,reacNumber] = getMappingInfo(models,abunFilePath,patNumb);
    writetable(cell2table(reacAbun,'VariableNames',['Reactions';sampName]'),strcat(resPath,'reactions.csv'));
    
    % Plotting genetic information
    [PCoA] = plotMappingInfo(resPath,patOrg,reacPat,reacTab,reacNumber,indInfoFilePath,figForm,sampName,strains); 
    
    if compMod == 1
       mkdir(strcat(resPath,'compfile'))
       writetable([array2table(reac),array2table(reacTab,'VariableNames',sampName')],[resPath 'compfile' filesep 'ReacTab.csv'])
       writetable(cell2table(reacSet,'VariableNames',sampName'),[resPath 'compfile' filesep 'reacSet.csv'])
       writetable([array2table(strains),array2table(reacPat,'VariableNames',sampName')],[resPath 'compfile' filesep 'ReacPat.csv'])
       csvwrite(strcat(resPath,'compfile/PCoA_tab.csv'),PCoA)
    end
    
    %Save all the created variables
    
    %Create tables and save all the created variables
    reacTab=[array2table(reac),array2table(reacTab,'VariableNames',sampName')],[resPath 'compfile' filesep 'ReacTab.csv'];
    reacSet=cell2table(reacSet,'VariableNames',sampName');
    reacPat=[array2table(strains),array2table(reacPat,'VariableNames',sampName')];
    
    save(strcat(resPath,'mapInfo.mat'))
end
%end of trigger for Autoload
%% PIPELINE: [PART 2.1]
% Checking consistency of inputs: if autofix == 0 halts execution with error 
% msg if inconsistencies are detected, otherwise it really tries hard to fix the 
% problem and continues execution when possible. 

[autoStat,fixVec,strains]=checkNomenConsist(strains,autoFix);
%% 
% Now we detect from the content of the results folder If PART2 was already 
% computed: if the associated file is already present in the results folder its 
% execution is skipped else its execution starts

[mapP]=detectOutput(resPath,'Setup_allbacs.mat');

if isempty(mapP)
    modbuild = 1;
else
    modbuild = 0;
    s= 'global setup file found: loading from resPath and skipping [PART2.1] analysis';
    disp(s)
end
%end of trigger for Autoload
%% 
% A model joining all the reconstructions contained in the study will be 
% created in this section. This model will be later used, integrating abundances 
% coming from the metagenomic sequencing, to derive the different microbiota models. 
% The result of this section will be automatically saved in the results folder. 

if modbuild == 1
   setup=fastSetupCreator(models, strains, {},objre)
   setup.name='Global reconstruction with lumen / fecal compartments no host';
   setup.recon=0;
   save(strcat(resPath,'Setup_allbacs.mat'), 'setup')
end

if modbuild==0
    load(strcat(resPath,'Setup_allbacs.mat')) 
end
%% PIPELINE: [PART 2.2]
% Now we will create the different microbiota models integrating the given abundances. 
% Coupling constraints and personalized "cumulative biomass" objective functions 
% are also added. Models that are already existent will not be recreated, and 
% new microbiota models will be saved in the results folder. 

[createdModels]=createPersonalizedModel(abunFilePath,resPath,setup,sampName,strains,patNumb)
%% PIPELINE: [PART 3]
% In this phase, for each microbiota model, a diet, in the form of set constraints 
% to the exchanges reactions of the diet compartment, is integrated. Flux Variability 
% analysis for all the exchange reactions of the diet and fecal compartment is 
% also computed and saved in a file called "simRes". Specifically what computed 
% and saved are:
% 
% # *ID* a vector containing the names of metabolites for which FVA of exchange 
% reactions was computed
% # *fvaCt* a cell array containing min flux trough uptake and max trough secretion 
% exchanges (later used for computing NMPCs)
% # *nsCT* a cell array containing max flux trough uptake and min trough secretion 
% exchanges
% # *presol* an array containing the value of objectives for each microbiota 
% model with rich and selected diet
% # *inFesMat* cell array containing the names of the microbiota models that 
% reported an infeasible status when solved for their objective 

[ID,fvaCt,nsCt,presol,inFesMat]=microbiotaModelSimulator(resPath,setup,sampName,dietFilePath,rDiet,0,extSolve,patNumb,fvaType)
%% 
% Finally, NMPCs (net maximal production capability) are computed in a metabolite 
% resolved manner and saved in a comma delimited file in the results folder. NMPCs 
% indicate the maximal production of each metabolite and are computed as the absolute 
% value of the sum of the maximal secretion flux with the maximal uptake flux. 
% The similarity of metabolic profiles (using the different NMPCs as features) 
% between individuals is also evaluated with classical multidimensional scaling. 

[Fsp,Y]= mgSimResCollect(resPath,ID,sampName,rDiet,0,patNumb,indInfoFilePath,fvaCt,figForm);
%% 
% Additionally, it is possible to retrieve and export, comprehensively, 
% all the results (fluxes) computed during the simulations for a specified diet. 
% Since FVA is computed on diet and fecal exchanges, every metabolite will have 
% four different values for each individual, values corresponding min and max 
% of uptake and secretion. 

[finRes] = extractFullRes(resPath, ID, 'sDiet', sampName, fvaCt, nsCt);
##### SOURCE END #####
--></body></html>